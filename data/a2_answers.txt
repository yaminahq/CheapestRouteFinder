3.1
This problem can be solved using an edge weighted digraph, the nodes of the graph represent cities and the edges the costs associated with the meal at the city at the head of the edge. Since the problem only requires going from a starting destination to a final destination a digraph is sufficient. This is because at a given city, to efficiently solve the problem, it only makes sense to go to a city closer to the final destination and not one closer to the source destination. Thus the graph can be setup in such a way where an edge connecting two cities is directed towards the city that is closer to the destination, from the two. This problem requires an edge weighted graph as we are trying to minimize the cost of the trip. If we assign a weight to each edge determined by the price of the meal at the head of the edge, then we can easily use a shortest path algorithm to find a path to the destination that minimizes the sum of these costs. Thus this will produce a path to the destination that minimizes the expenses of meals at each city and from there the overall cost of the trip. Therefore, the nodes of the graphs must be cities and the edges must represent the cost of the least expensive meal at the city at the head of the directed edge. Along with this data structure, solving the problem will also require algorithms. A breadth-first or depth-first search can be used to find a path connecting the source city to the destination city.  Dijkstra’s Shortest path algorithm can be used to find the path from the source city to the destination city that minimizes the total expenses from meals at each city. An approach to solve the problem is to use Dijkstra’s algorithm and find the cheapest meal at each city along the path, if this meal was consumed at the previous city then dynamically replace it with the second cheapest meal option at that city. This can be done by modifying the relax() method used by the algorithm to update the weight of the edge. The path produced by this modified Dijkstra’s algorithm will be the cheapest route to the destination.

3.2
The breadth-first search found the destination in fewer stops than the depth-first search. However, both required the same number of steps to find the path. This is because each algorithm searched every single node on the graph. However, the nature of the BFS is to find the smallest path. This is because it traverses the graph level by level using a queue as opposed to the DFS which traverses the depth of a single path until it reaches the end using a stack. This will remain true even if the number of stops increases. Increasing the number of stops will not alter the nature of the algorithms. Each algorithm will still search every node and the BFS will still do it in a way using a queue that results in the shortest possible path.

3.4
The complexity of this algorithm O(ElogV), where E is the number of edges in the graph and V is the number of vertices or nodes in the graph. This is because the algorithm will traverse over every single edge in the graph, hence the E in the time complexity. Furthermore, the algorithm is implemented using a minimum index priority queue. This data structure has a time complexity of O(logV) to insert or modify any element in the queue. Since for each edge we either change or insert something into the priority queue the overall time complexity we get is O(ElogV). The complexity will remain the system regardless of whether the cities, stops or restaurants are modified. Dijkstra’s shortest path algorithm depends solely on the number of edges and vertices in the graph and will always have a time complexity proportional to these values. 
